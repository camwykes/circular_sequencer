<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Circular Sequencer</title>
<style>

        * {

            margin: 0;

            padding: 0;

            box-sizing: border-box;

        }

```

    body {

        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

        background: #111827;

        color: white;

        padding: 24px;

        min-height: 100vh;

    }

    .container {

        max-width: 1400px;

        margin: 0 auto;

    }

    h1 {

        font-size: 2rem;

        margin-bottom: 24px;

    }

    .master-controls {

        background: #1f2937;

        border-radius: 8px;

        padding: 24px;

        margin-bottom: 24px;

    }

    .control-row {

        display: flex;

        gap: 24px;

        align-items: center;

        margin-bottom: 16px;

        flex-wrap: wrap;

    }

    .btn {

        padding: 12px 24px;

        border: none;

        border-radius: 8px;

        cursor: pointer;

        font-size: 1rem;

        display: flex;

        align-items: center;

        gap: 8px;

        transition: background 0.2s;

    }

    .btn-primary {

        background: #3b82f6;

        color: white;

    }

    .btn-primary:hover {

        background: #2563eb;

    }

    .btn-success {

        background: #10b981;

        color: white;

    }

    .btn-success:hover {

        background: #059669;

    }

    .btn-danger {

        background: #ef4444;

        color: white;

        padding: 8px 16px;

    }

    .btn-danger:hover {

        background: #dc2626;

    }

    .btn-record {

        background: #ef4444;

        color: white;

    }

    .btn-record:hover {

        background: #dc2626;

    }

    .btn-record.recording {

        background: #dc2626;

        animation: pulse 1.5s infinite;

    }

    @keyframes pulse {

        0%, 100% { opacity: 1; }

        50% { opacity: 0.7; }

    }

    .input-group {

        display: flex;

        align-items: center;

        gap: 12px;

    }

    input[type="number"] {

        background: #374151;

        border: none;

        color: white;

        padding: 8px 12px;

        border-radius: 4px;

        width: 80px;

    }

    .slider-grid {

        display: grid;

        grid-template-columns: repeat(3, 1fr);

        gap: 24px;

        margin-top: 16px;

    }

    .slider-control {

        display: flex;

        flex-direction: column;

        gap: 8px;

    }

    input[type="range"] {

        width: 100%;

        height: 6px;

        border-radius: 3px;

        background: #374151;

        outline: none;

        -webkit-appearance: none;

    }

    input[type="range"]::-webkit-slider-thumb {

        -webkit-appearance: none;

        appearance: none;

        width: 18px;

        height: 18px;

        border-radius: 50%;

        background: #3b82f6;

        cursor: pointer;

    }

    input[type="range"]::-moz-range-thumb {

        width: 18px;

        height: 18px;

        border-radius: 50%;

        background: #3b82f6;

        cursor: pointer;

        border: none;

    }

    .lanes {

        display: flex;

        flex-direction: column;

        gap: 16px;

    }

    .lane {

        background: #1f2937;

        border-radius: 8px;

        padding: 24px;

        display: flex;

        gap: 24px;

    }

    .lane-visual {

        flex-shrink: 0;

    }

    .lane-controls {

        flex: 1;

        display: grid;

        grid-template-columns: repeat(2, 1fr);

        gap: 16px;

    }

    .control-item {

        display: flex;

        flex-direction: column;

        gap: 8px;

    }

    .control-item label {

        font-size: 0.875rem;

        color: #9ca3af;

    }

    .file-input-wrapper {

        display: flex;

        gap: 8px;

        align-items: center;

    }

    .file-label {

        background: #374151;

        padding: 8px 12px;

        border-radius: 4px;

        cursor: pointer;

        font-size: 0.875rem;

        transition: background 0.2s;

    }

    .file-label:hover {

        background: #4b5563;

    }

    .file-name {

        font-size: 0.875rem;

        color: #9ca3af;

    }

    input[type="file"] {

        display: none;

    }

    .checkbox-group {

        display: flex;

        align-items: center;

        gap: 16px;

    }

    input[type="checkbox"] {

        width: 18px;

        height: 18px;

        cursor: pointer;

    }

    .info {

        margin-top: 24px;

        font-size: 0.875rem;

        color: #9ca3af;

    }

    canvas {

        background: #111827;

        border-radius: 8px;

    }

    .sample-library {

        background: #1f2937;

        border-radius: 8px;

        padding: 24px;

        margin-bottom: 24px;

    }

    .sample-grid {

        display: grid;

        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));

        gap: 12px;

        margin-top: 12px;

    }

    .sample-btn {

        background: #374151;

        border: 2px solid #4b5563;

        color: white;

        padding: 12px;

        border-radius: 6px;

        cursor: pointer;

        font-size: 0.875rem;

        transition: all 0.2s;

    }

    .sample-btn:hover {

        background: #4b5563;

        border-color: #60a5fa;

    }

    .sample-btn.selected {

        background: #3b82f6;

        border-color: #3b82f6;

    }

    .filter-controls {

        display: grid;

        grid-template-columns: 1fr 1fr;

        gap: 12px;

        margin-top: 8px;

        padding-top: 8px;

        border-top: 1px solid #374151;

    }

    select {

        background: #374151;

        border: none;

        color: white;

        padding: 6px 10px;

        border-radius: 4px;

        cursor: pointer;

    }
</style>

```
</head>
<body>
<div class="container">
<h1>Circular Sequencer</h1>

```
<div class="master-controls">
<div class="control-row">
<button id="playBtn" class="btn btn-primary">
<span>‚ñ∂</span> Play
</button>
<div class="input-group">
<label>BPM:</label>
<input type="number" id="bpmInput" value="120" min="40" max="240">
</div>
<button id="addLaneBtn" class="btn btn-success">
<span>+</span> Add Lane
</button>
<button id="recordBtn" class="btn btn-record">
<span>‚è∫</span> Record
</button>
</div>
<div class="slider-grid">
<div class="slider-control">
<label>Master Volume</label>
<input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.8">
</div>
<div class="slider-control">
<label>Reverb</label>
<input type="range" id="reverb" min="0" max="1" step="0.01" value="0.3">
</div>
<div class="slider-control">
<label>Delay</label>
<input type="range" id="delay" min="0" max="1" step="0.01" value="0.2">
</div>
</div>
</div>
<div class="sample-library">
<h2 style="margin-bottom: 12px; font-size: 1.25rem;">Sample Library</h2>
<p style="font-size: 0.875rem; color: #9ca3af; margin-bottom: 12px;">Click a sample, then click "Use" on a lane to load it</p>
<div class="sample-grid" id="sampleLibrary"></div>
</div>
<div id="lanes" class="lanes"></div>
<div class="info">
<p>Load audio samples into each lane and press play. Each circular lane rotates at different speeds, creating polyrhythmic patterns.</p>
</div>
</div>
<script>

    let audioContext;

    let isPlaying = false;

    let bpm = 120;

    let lanes = [];

    let nextLaneId = 1;

    let animationFrameId = null;

    let lanePositions = {};

    let buffers = {};

    let effects = {};

    let isRecording = false;

    let mediaRecorder = null;

    let recordedChunks = [];

    let selectedSample = null;

    // Sample library - using Web Audio API to generate sounds

    const sampleLibrary = {

        'Kick': { type: 'kick' },

        'Snare': { type: 'snare' },

        'Hi-Hat': { type: 'hihat' },

        'Clap': { type: 'clap' },

        'Tom': { type: 'tom' },

        'Rim': { type: 'rim' },

        'Bass': { type: 'bass' },

        'Synth': { type: 'synth' },

        'Blip': { type: 'blip' },

        'Noise': { type: 'noise' }

    };

    // Initialize

    function init() {

        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Create effects chain

        const masterGain = audioContext.createGain();

        masterGain.gain.value = 0.8;

        masterGain.connect(audioContext.destination);

        const reverbNode = audioContext.createConvolver();

        const reverbGain = audioContext.createGain();

        reverbGain.gain.value = 0.3;

        reverbGain.connect(masterGain);

        const delayNode = audioContext.createDelay(2);

        delayNode.delayTime.value = 0.25;

        const delayFeedback = audioContext.createGain();

        delayFeedback.gain.value = 0.15;

        const delayGain = audioContext.createGain();

        delayGain.gain.value = 0.2;

        delayNode.connect(delayFeedback);

        delayFeedback.connect(delayNode);

        delayNode.connect(delayGain);

        delayGain.connect(masterGain);

        effects = { masterGain, reverbNode, reverbGain, delayNode, delayGain, delayFeedback };

        createReverbImpulse(audioContext, reverbNode);

        // Event listeners

        document.getElementById('playBtn').addEventListener('click', togglePlay);

        document.getElementById('bpmInput').addEventListener('input', (e) => {

            bpm = parseInt(e.target.value);

        });

        document.getElementById('addLaneBtn').addEventListener('click', addLane);

        document.getElementById('recordBtn').addEventListener('click', toggleRecording);

        document.getElementById('masterVolume').addEventListener('input', (e) => {

            effects.masterGain.gain.value = parseFloat(e.target.value);

        });

        document.getElementById('reverb').addEventListener('input', (e) => {

            effects.reverbGain.gain.value = parseFloat(e.target.value);

        });

        document.getElementById('delay').addEventListener('input', (e) => {

            const val = parseFloat(e.target.value);

            effects.delayGain.gain.value = val;

            effects.delayFeedback.gain.value = val * 0.5;

        });

        // Render sample library

        renderSampleLibrary();

        // Add initial lanes

        addLane();

        addLane();

        addLane();

    }

    function renderSampleLibrary() {

        const container = document.getElementById('sampleLibrary');

        Object.keys(sampleLibrary).forEach(name => {

            const btn = document.createElement('button');

            btn.className = 'sample-btn';

            btn.textContent = name;

            btn.onclick = () => selectSample(name, btn);

            container.appendChild(btn);

        });

    }

    function selectSample(name, btn) {

        document.querySelectorAll('.sample-btn').forEach(b => b.classList.remove('selected'));

        btn.classList.add('selected');

        selectedSample = name;

    }

    async function generateSample(type) {

        const sampleRate = audioContext.sampleRate;

        const duration = type === 'bass' || type === 'synth' ? 0.5 : 0.2;

        const buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);

        const data = buffer.getChannelData(0);

        switch(type) {

            case 'kick':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 15);

                    const freq = 150 * Math.exp(-t * 30);

                    data[i] = Math.sin(2 * Math.PI * freq * t) * env;

                }

                break;

            case 'snare':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 20);

                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.3;

                    const noise = (Math.random() * 2 - 1) * 0.7;

                    data[i] = (tone + noise) * env;

                }

                break;

            case 'hihat':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 40);

                    data[i] = (Math.random() * 2 - 1) * env;

                }

                break;

            case 'clap':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    let env = 0;

                    if (t < 0.01) env = 1;

                    else if (t < 0.03) env = Math.exp(-(t-0.01) * 50);

                    else if (t < 0.04) env = 0.7;

                    else env = Math.exp(-(t-0.04) * 30) * 0.7;

                    data[i] = (Math.random() * 2 - 1) * env;

                }

                break;

            case 'tom':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 10);

                    const freq = 120 * Math.exp(-t * 8);

                    data[i] = Math.sin(2 * Math.PI * freq * t) * env;

                }

                break;

            case 'rim':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 60);

                    const freq = 800 + Math.sin(2 * Math.PI * 100 * t) * 200;

                    data[i] = Math.sin(2 * Math.PI * freq * t) * env * 0.5;

                }

                break;

            case 'bass':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 3);

                    data[i] = Math.sin(2 * Math.PI * 110 * t) * env;

                }

                break;

            case 'synth':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 4);

                    const freq = 440;

                    data[i] = (Math.sin(2 * Math.PI * freq * t) + 

                              Math.sin(2 * Math.PI * freq * 2 * t) * 0.5) * env * 0.5;

                }

                break;

            case 'blip':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 30);

                    const freq = 800 * Math.exp(-t * 20);

                    data[i] = Math.sin(2 * Math.PI * freq * t) * env;

                }

                break;

            case 'noise':

                for (let i = 0; i < data.length; i++) {

                    const t = i / sampleRate;

                    const env = Math.exp(-t * 15);

                    data[i] = (Math.random() * 2 - 1) * env;

                }

                break;

        }

        return buffer;

    }

    function createReverbImpulse(ctx, convolver) {

        const rate = ctx.sampleRate;

        const length = rate * 2;

        const impulse = ctx.createBuffer(2, length, rate);

        const left = impulse.getChannelData(0);

        const right = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {

            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);

            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);

        }

        convolver.buffer = impulse;

    }

    function togglePlay() {

        isPlaying = !isPlaying;

        const btn = document.getElementById('playBtn');

        if (isPlaying) {

            btn.innerHTML = '<span>‚è∏</span> Pause';

            animate();

        } else {

            btn.innerHTML = '<span>‚ñ∂</span> Play';

            if (animationFrameId) {

                cancelAnimationFrame(animationFrameId);

            }

        }

    }

    async function toggleRecording() {

        if (!isRecording) {

            // Start recording

            const stream = audioContext.createMediaStreamDestination();

            effects.masterGain.connect(stream);

            mediaRecorder = new MediaRecorder(stream.stream);

            recordedChunks = [];

            mediaRecorder.ondataavailable = (e) => {

                if (e.data.size > 0) {

                    recordedChunks.push(e.data);

                }

            };

            mediaRecorder.onstop = () => {

                const blob = new Blob(recordedChunks, { type: 'audio/webm' });

                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');

                a.href = url;

                a.download = `sequencer-recording-${Date.now()}.webm`;

                a.click();

            };

            mediaRecorder.start();

            isRecording = true;

            document.getElementById('recordBtn').classList.add('recording');

            document.getElementById('recordBtn').innerHTML = '<span>‚èπ</span> Stop Recording';

        } else {

            // Stop recording

            mediaRecorder.stop();

            isRecording = false;

            document.getElementById('recordBtn').classList.remove('recording');

            document.getElementById('recordBtn').innerHTML = '<span>‚è∫</span> Record';

        }

    }

    function addLane() {

        const lane = {

            id: nextLaneId++,

            steps: 8,

            speed: 1,

            sample: null,

            volume: 0.7,

            pitch: 1,

            active: true,

            filterType: 'none',

            filterFreq: 1000

        };

        lanes.push(lane);

        renderLane(lane);

    }

    function removeLane(id) {

        lanes = lanes.filter(l => l.id !== id);

        delete buffers[id];

        delete lanePositions[id];

        document.getElementById(`lane-${id}`).remove();

    }

    function updateLane(id, updates) {

        const lane = lanes.find(l => l.id === id);

        if (lane) {

            Object.assign(lane, updates);

        }

    }

    function renderLane(lane) {

        const laneDiv = document.createElement('div');

        laneDiv.className = 'lane';
laneDiv.id = `lane-${lane.id}`;

        laneDiv.innerHTML = `
<div class="lane-visual">
<canvas id="canvas-${lane.id}" width="160" height="160"></canvas>
</div>
<div class="lane-controls">
<div class="control-item">
<label>Sample</label>
<div class="file-input-wrapper">
<button class="file-label" id="use-sample-${lane.id}">Use Selected</button>
<label for="file-${lane.id}" class="file-label">üìÅ Load File</label>
<input type="file" id="file-${lane.id}" accept="audio/*">
<span class="file-name" id="filename-${lane.id}">No sample</span>
</div>
<div class="filter-controls">
<div>
<label style="font-size: 0.75rem;">Filter Type</label>
<select id="filter-type-${lane.id}">
<option value="none">None</option>
<option value="lowpass">Low Pass</option>
<option value="highpass">High Pass</option>
<option value="bandpass">Band Pass</option>
</select>
</div>
<div>
<label style="font-size: 0.75rem;">Frequency: <span id="filter-freq-val-${lane.id}">1000</span>Hz</label>
<input type="range" id="filter-freq-${lane.id}" min="100" max="8000" value="1000">
</div>
</div>
</div>
<div class="control-item">
<label>Steps: <span id="steps-val-${lane.id}">${lane.steps}</span></label>
<input type="range" id="steps-${lane.id}" min="2" max="16" value="${lane.steps}">
</div>
<div class="control-item">
<label>Speed: <span id="speed-val-${lane.id}">${lane.speed.toFixed(2)}x</span></label>
<input type="range" id="speed-${lane.id}" min="0.25" max="4" step="0.25" value="${lane.speed}">
</div>
<div class="control-item">
<label>Volume</label>
<input type="range" id="volume-${lane.id}" min="0" max="1" step="0.01" value="${lane.volume}">
</div>
<div class="control-item">
<label>Pitch: <span id="pitch-val-${lane.id}">${lane.pitch.toFixed(2)}x</span></label>
<input type="range" id="pitch-${lane.id}" min="0.5" max="2" step="0.01" value="${lane.pitch}">
</div>
<div class="control-item checkbox-group">
<label>
<input type="checkbox" id="active-${lane.id}" checked> Active
</label>
<button class="btn btn-danger" id="remove-${lane.id}">üóë Remove</button>
</div>
</div>

        `;

        document.getElementById('lanes').appendChild(laneDiv);

        // Use selected sample button

        document.getElementById(`use-sample-${lane.id}`).addEventListener('click', async () => {

            if (selectedSample) {

                const sampleType = sampleLibrary[selectedSample].type;

                const buffer = await generateSample(sampleType);

                buffers[lane.id] = buffer;

                document.getElementById(`filename-${lane.id}`).textContent = selectedSample;

            }

        });

        // File input

        document.getElementById(`file-${lane.id}`).addEventListener('change', async (e) => {

            if (e.target.files[0]) {

                await loadSample(lane.id, e.target.files[0]);

                document.getElementById(`filename-${lane.id}`).textContent = e.target.files[0].name;

            }

        });

        // Filter controls

        document.getElementById(`filter-type-${lane.id}`).addEventListener('change', (e) => {

            updateLane(lane.id, { filterType: e.target.value });

        });

        document.getElementById(`filter-freq-${lane.id}`).addEventListener('input', (e) => {

            const val = parseInt(e.target.value);

            updateLane(lane.id, { filterFreq: val });

            document.getElementById(`filter-freq-val-${lane.id}`).textContent = val;

        });

        document.getElementById(`steps-${lane.id}`).addEventListener('input', (e) => {

            const val = parseInt(e.target.value);

            updateLane(lane.id, { steps: val });

            document.getElementById(`steps-val-${lane.id}`).textContent = val;

        });

        document.getElementById(`speed-${lane.id}`).addEventListener('input', (e) => {

            const val = parseFloat(e.target.value);

            updateLane(lane.id, { speed: val });

            document.getElementById(`speed-val-${lane.id}`).textContent = val.toFixed(2) + 'x';

        });

        document.getElementById(`volume-${lane.id}`).addEventListener('input', (e) => {

            updateLane(lane.id, { volume: parseFloat(e.target.value) });

        });

        document.getElementById(`pitch-${lane.id}`).addEventListener('input', (e) => {

            const val = parseFloat(e.target.value);

            updateLane(lane.id, { pitch: val });

            document.getElementById(`pitch-val-${lane.id}`).textContent = val.toFixed(2) + 'x';

        });

        document.getElementById(`active-${lane.id}`).addEventListener('change', (e) => {

            updateLane(lane.id, { active: e.target.checked });

        });

        document.getElementById(`remove-${lane.id}`).addEventListener('click', () => {

            removeLane(lane.id);

        });

        drawLane(lane);

    }

    async function loadSample(laneId, file) {

        const arrayBuffer = await file.arrayBuffer();

        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        buffers[laneId] = audioBuffer;

    }

    function playSample(laneId) {

        const buffer = buffers[laneId];

        const lane = lanes.find(l => l.id === laneId);

        if (!buffer || !lane || !lane.active) return;

        const source = audioContext.createBufferSource();

        source.buffer = buffer;

        const gainNode = audioContext.createGain();

        gainNode.gain.value = lane.volume;

        source.playbackRate.value = lane.pitch;

        // Apply filter if enabled

        if (lane.filterType !== 'none') {

            const filter = audioContext.createBiquadFilter();

            filter.type = lane.filterType;

            filter.frequency.value = lane.filterFreq;

            source.connect(filter);

            filter.connect(gainNode);

        } else {

            source.connect(gainNode);

        }

        gainNode.connect(effects.masterGain);

        gainNode.connect(effects.reverbGain);

        gainNode.connect(effects.delayNode);

        source.start();

    }

    function drawLane(lane) {

        const canvas = document.getElementById(`canvas-${lane.id}`);

        if (!canvas) return;

        const ctx = canvas.getContext('2d');

        const centerX = canvas.width / 2;

        const centerY = canvas.height / 2;

        const radius = 60;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw circle

        ctx.strokeStyle = lane.active ? '#60a5fa' : '#9ca3af';

        ctx.lineWidth = 2;

        ctx.beginPath();

        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);

        ctx.stroke();

        // Draw steps

        for (let i = 0; i < lane.steps; i++) {

            const angle = (i / lane.steps) * Math.PI * 2 - Math.PI / 2;

            const x = centerX + Math.cos(angle) * radius;

            const y = centerY + Math.sin(angle) * radius;

            ctx.fillStyle = lane.active ? '#60a5fa' : '#9ca3af';

            ctx.beginPath();

            ctx.arc(x, y, 4, 0, Math.PI * 2);

            ctx.fill();

        }

        // Draw playhead

        if (isPlaying && lane.active) {

            const position = lanePositions[lane.id] || 0;

            const angle = (position / (lane.steps * 100)) * Math.PI * 2 - Math.PI / 2;

            const x = centerX + Math.cos(angle) * radius;

            const y = centerY + Math.sin(angle) * radius;

            ctx.fillStyle = '#ef4444';

            ctx.beginPath();

            ctx.arc(x, y, 8, 0, Math.PI * 2);

            ctx.fill();

        }

    }

    let lastTriggerTime = {};

    function animate(timestamp = 0) {

        if (!isPlaying) return;

        lanes.forEach(lane => {

            if (!lane.active) return;

            const position = (timestamp * lane.speed * (bpm / 120)) % (lane.steps * 100);

            const currentStep = Math.floor(position / 100);

            if (!lastTriggerTime[lane.id]) {

                lastTriggerTime[lane.id] = { step: -1, time: 0 };

            }

            if (currentStep !== lastTriggerTime[lane.id].step && 

                timestamp - lastTriggerTime[lane.id].time > 50) {

                playSample(lane.id);

                lastTriggerTime[lane.id] = { step: currentStep, time: timestamp };

            }

            lanePositions[lane.id] = position;

            drawLane(lane);

        });

        animationFrameId = requestAnimationFrame(animate);

    }

    // Start the app

    init();
</script>

```
</body>
</html>
 
