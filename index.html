<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Circular Sequencer</title>
<style>

        * {

            margin: 0;

            padding: 0;

            box-sizing: border-box;

        }

```

    body {

        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;

        background: #111827;

        color: white;

        padding: 24px;

        min-height: 100vh;

    }

    .container {

        max-width: 1400px;

        margin: 0 auto;

    }

    h1 {

        font-size: 2rem;

        margin-bottom: 24px;

    }

    .master-controls {

        background: #1f2937;

        border-radius: 8px;

        padding: 24px;

        margin-bottom: 24px;

    }

    .control-row {

        display: flex;

        gap: 24px;

        align-items: center;

        margin-bottom: 16px;

        flex-wrap: wrap;

    }

    .btn {

        padding: 12px 24px;

        border: none;

        border-radius: 8px;

        cursor: pointer;

        font-size: 1rem;

        display: flex;

        align-items: center;

        gap: 8px;

        transition: background 0.2s;

    }

    .btn-primary {

        background: #3b82f6;

        color: white;

    }

    .btn-primary:hover {

        background: #2563eb;

    }

    .btn-success {

        background: #10b981;

        color: white;

    }

    .btn-success:hover {

        background: #059669;

    }

    .btn-danger {

        background: #ef4444;

        color: white;

        padding: 8px 16px;

    }

    .btn-danger:hover {

        background: #dc2626;

    }

    .input-group {

        display: flex;

        align-items: center;

        gap: 12px;

    }

    input[type="number"] {

        background: #374151;

        border: none;

        color: white;

        padding: 8px 12px;

        border-radius: 4px;

        width: 80px;

    }

    .slider-grid {

        display: grid;

        grid-template-columns: repeat(3, 1fr);

        gap: 24px;

        margin-top: 16px;

    }

    .slider-control {

        display: flex;

        flex-direction: column;

        gap: 8px;

    }

    input[type="range"] {

        width: 100%;

        height: 6px;

        border-radius: 3px;

        background: #374151;

        outline: none;

        -webkit-appearance: none;

    }

    input[type="range"]::-webkit-slider-thumb {

        -webkit-appearance: none;

        appearance: none;

        width: 18px;

        height: 18px;

        border-radius: 50%;

        background: #3b82f6;

        cursor: pointer;

    }

    input[type="range"]::-moz-range-thumb {

        width: 18px;

        height: 18px;

        border-radius: 50%;

        background: #3b82f6;

        cursor: pointer;

        border: none;

    }

    .lanes {

        display: flex;

        flex-direction: column;

        gap: 16px;

    }

    .lane {

        background: #1f2937;

        border-radius: 8px;

        padding: 24px;

        display: flex;

        gap: 24px;

    }

    .lane-visual {

        flex-shrink: 0;

    }

    .lane-controls {

        flex: 1;

        display: grid;

        grid-template-columns: repeat(2, 1fr);

        gap: 16px;

    }

    .control-item {

        display: flex;

        flex-direction: column;

        gap: 8px;

    }

    .control-item label {

        font-size: 0.875rem;

        color: #9ca3af;

    }

    .file-input-wrapper {

        display: flex;

        gap: 8px;

        align-items: center;

    }

    .file-label {

        background: #374151;

        padding: 8px 12px;

        border-radius: 4px;

        cursor: pointer;

        font-size: 0.875rem;

        transition: background 0.2s;

    }

    .file-label:hover {

        background: #4b5563;

    }

    .file-name {

        font-size: 0.875rem;

        color: #9ca3af;

    }

    input[type="file"] {

        display: none;

    }

    .checkbox-group {

        display: flex;

        align-items: center;

        gap: 16px;

    }

    input[type="checkbox"] {

        width: 18px;

        height: 18px;

        cursor: pointer;

    }

    .info {

        margin-top: 24px;

        font-size: 0.875rem;

        color: #9ca3af;

    }

    canvas {

        background: #111827;

        border-radius: 8px;

    }
</style>

```
</head>
<body>
<div class="container">
<h1>Circular Sequencer</h1>

```
<div class="master-controls">
<div class="control-row">
<button id="playBtn" class="btn btn-primary">
<span>‚ñ∂</span> Play
</button>
<div class="input-group">
<label>BPM:</label>
<input type="number" id="bpmInput" value="120" min="40" max="240">
</div>
<button id="addLaneBtn" class="btn btn-success">
<span>+</span> Add Lane
</button>
</div>
<div class="slider-grid">
<div class="slider-control">
<label>Master Volume</label>
<input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.8">
</div>
<div class="slider-control">
<label>Reverb</label>
<input type="range" id="reverb" min="0" max="1" step="0.01" value="0.3">
</div>
<div class="slider-control">
<label>Delay</label>
<input type="range" id="delay" min="0" max="1" step="0.01" value="0.2">
</div>
</div>
</div>
<div id="lanes" class="lanes"></div>
<div class="info">
<p>Load audio samples into each lane and press play. Each circular lane rotates at different speeds, creating polyrhythmic patterns.</p>
</div>
</div>
<script>

    let audioContext;

    let isPlaying = false;

    let bpm = 120;

    let lanes = [];

    let nextLaneId = 1;

    let animationFrameId = null;

    let lanePositions = {};

    let buffers = {};

    let effects = {};

    // Initialize

    function init() {

        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Create effects chain

        const masterGain = audioContext.createGain();

        masterGain.gain.value = 0.8;

        masterGain.connect(audioContext.destination);

        const reverbNode = audioContext.createConvolver();

        const reverbGain = audioContext.createGain();

        reverbGain.gain.value = 0.3;

        reverbGain.connect(masterGain);

        const delayNode = audioContext.createDelay(2);

        delayNode.delayTime.value = 0.25;

        const delayFeedback = audioContext.createGain();

        delayFeedback.gain.value = 0.15;

        const delayGain = audioContext.createGain();

        delayGain.gain.value = 0.2;

        delayNode.connect(delayFeedback);

        delayFeedback.connect(delayNode);

        delayNode.connect(delayGain);

        delayGain.connect(masterGain);

        effects = { masterGain, reverbNode, reverbGain, delayNode, delayGain, delayFeedback };

        createReverbImpulse(audioContext, reverbNode);

        // Event listeners

        document.getElementById('playBtn').addEventListener('click', togglePlay);

        document.getElementById('bpmInput').addEventListener('input', (e) => {

            bpm = parseInt(e.target.value);

        });

        document.getElementById('addLaneBtn').addEventListener('click', addLane);

        document.getElementById('masterVolume').addEventListener('input', (e) => {

            effects.masterGain.gain.value = parseFloat(e.target.value);

        });

        document.getElementById('reverb').addEventListener('input', (e) => {

            effects.reverbGain.gain.value = parseFloat(e.target.value);

        });

        document.getElementById('delay').addEventListener('input', (e) => {

            const val = parseFloat(e.target.value);

            effects.delayGain.gain.value = val;

            effects.delayFeedback.gain.value = val * 0.5;

        });

        // Add initial lanes

        addLane();

        addLane();

        addLane();

    }

    function createReverbImpulse(ctx, convolver) {

        const rate = ctx.sampleRate;

        const length = rate * 2;

        const impulse = ctx.createBuffer(2, length, rate);

        const left = impulse.getChannelData(0);

        const right = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {

            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);

            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);

        }

        convolver.buffer = impulse;

    }

    function togglePlay() {

        isPlaying = !isPlaying;

        const btn = document.getElementById('playBtn');

        if (isPlaying) {

            btn.innerHTML = '<span>‚è∏</span> Pause';

            animate();

        } else {

            btn.innerHTML = '<span>‚ñ∂</span> Play';

            if (animationFrameId) {

                cancelAnimationFrame(animationFrameId);

            }

        }

    }

    function addLane() {

        const lane = {

            id: nextLaneId++,

            steps: 8,

            speed: 1,

            sample: null,

            volume: 0.7,

            pitch: 1,

            active: true

        };

        lanes.push(lane);

        renderLane(lane);

    }

    function removeLane(id) {

        lanes = lanes.filter(l => l.id !== id);

        delete buffers[id];

        delete lanePositions[id];

        document.getElementById(`lane-${id}`).remove();

    }

    function updateLane(id, updates) {

        const lane = lanes.find(l => l.id === id);

        if (lane) {

            Object.assign(lane, updates);

        }

    }

    function renderLane(lane) {

        const laneDiv = document.createElement('div');

        laneDiv.className = 'lane';
laneDiv.id = `lane-${lane.id}`;

        laneDiv.innerHTML = `
<div class="lane-visual">
<canvas id="canvas-${lane.id}" width="160" height="160"></canvas>
</div>
<div class="lane-controls">
<div class="control-item">
<label>Sample</label>
<div class="file-input-wrapper">
<label for="file-${lane.id}" class="file-label">üìÅ Load</label>
<input type="file" id="file-${lane.id}" accept="audio/*">
<span class="file-name" id="filename-${lane.id}">No sample</span>
</div>
</div>
<div class="control-item">
<label>Steps: <span id="steps-val-${lane.id}">${lane.steps}</span></label>
<input type="range" id="steps-${lane.id}" min="2" max="16" value="${lane.steps}">
</div>
<div class="control-item">
<label>Speed: <span id="speed-val-${lane.id}">${lane.speed.toFixed(2)}x</span></label>
<input type="range" id="speed-${lane.id}" min="0.25" max="4" step="0.25" value="${lane.speed}">
</div>
<div class="control-item">
<label>Volume</label>
<input type="range" id="volume-${lane.id}" min="0" max="1" step="0.01" value="${lane.volume}">
</div>
<div class="control-item">
<label>Pitch: <span id="pitch-val-${lane.id}">${lane.pitch.toFixed(2)}x</span></label>
<input type="range" id="pitch-${lane.id}" min="0.5" max="2" step="0.01" value="${lane.pitch}">
</div>
<div class="control-item checkbox-group">
<label>
<input type="checkbox" id="active-${lane.id}" checked> Active
</label>
<button class="btn btn-danger" id="remove-${lane.id}">üóë Remove</button>
</div>
</div>

        `;

        document.getElementById('lanes').appendChild(laneDiv);

        // Add event listeners

        document.getElementById(`file-${lane.id}`).addEventListener('change', async (e) => {

            if (e.target.files[0]) {

                await loadSample(lane.id, e.target.files[0]);

                document.getElementById(`filename-${lane.id}`).textContent = e.target.files[0].name;

            }

        });

        document.getElementById(`steps-${lane.id}`).addEventListener('input', (e) => {

            const val = parseInt(e.target.value);

            updateLane(lane.id, { steps: val });

            document.getElementById(`steps-val-${lane.id}`).textContent = val;

        });

        document.getElementById(`speed-${lane.id}`).addEventListener('input', (e) => {

            const val = parseFloat(e.target.value);

            updateLane(lane.id, { speed: val });

            document.getElementById(`speed-val-${lane.id}`).textContent = val.toFixed(2) + 'x';

        });

        document.getElementById(`volume-${lane.id}`).addEventListener('input', (e) => {

            updateLane(lane.id, { volume: parseFloat(e.target.value) });

        });

        document.getElementById(`pitch-${lane.id}`).addEventListener('input', (e) => {

            const val = parseFloat(e.target.value);

            updateLane(lane.id, { pitch: val });

            document.getElementById(`pitch-val-${lane.id}`).textContent = val.toFixed(2) + 'x';

        });

        document.getElementById(`active-${lane.id}`).addEventListener('change', (e) => {

            updateLane(lane.id, { active: e.target.checked });

        });

        document.getElementById(`remove-${lane.id}`).addEventListener('click', () => {

            removeLane(lane.id);

        });

        drawLane(lane);

    }

    async function loadSample(laneId, file) {

        const arrayBuffer = await file.arrayBuffer();

        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        buffers[laneId] = audioBuffer;

    }

    function playSample(laneId) {

        const buffer = buffers[laneId];

        const lane = lanes.find(l => l.id === laneId);

        if (!buffer || !lane || !lane.active) return;

        const source = audioContext.createBufferSource();

        source.buffer = buffer;

        const gainNode = audioContext.createGain();

        gainNode.gain.value = lane.volume;

        source.playbackRate.value = lane.pitch;

        source.connect(gainNode);

        gainNode.connect(effects.masterGain);

        gainNode.connect(effects.reverbGain);

        gainNode.connect(effects.delayNode);

        source.start();

    }

    function drawLane(lane) {

        const canvas = document.getElementById(`canvas-${lane.id}`);

        if (!canvas) return;

        const ctx = canvas.getContext('2d');

        const centerX = canvas.width / 2;

        const centerY = canvas.height / 2;

        const radius = 60;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw circle

        ctx.strokeStyle = lane.active ? '#60a5fa' : '#9ca3af';

        ctx.lineWidth = 2;

        ctx.beginPath();

        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);

        ctx.stroke();

        // Draw steps

        for (let i = 0; i < lane.steps; i++) {

            const angle = (i / lane.steps) * Math.PI * 2 - Math.PI / 2;

            const x = centerX + Math.cos(angle) * radius;

            const y = centerY + Math.sin(angle) * radius;

            ctx.fillStyle = lane.active ? '#60a5fa' : '#9ca3af';

            ctx.beginPath();

            ctx.arc(x, y, 4, 0, Math.PI * 2);

            ctx.fill();

        }

        // Draw playhead

        if (isPlaying && lane.active) {

            const position = lanePositions[lane.id] || 0;

            const angle = (position / (lane.steps * 100)) * Math.PI * 2 - Math.PI / 2;

            const x = centerX + Math.cos(angle) * radius;

            const y = centerY + Math.sin(angle) * radius;

            ctx.fillStyle = '#ef4444';

            ctx.beginPath();

            ctx.arc(x, y, 8, 0, Math.PI * 2);

            ctx.fill();

        }

    }

    let lastTriggerTime = {};

    function animate(timestamp = 0) {

        if (!isPlaying) return;

        lanes.forEach(lane => {

            if (!lane.active) return;

            const position = (timestamp * lane.speed * (bpm / 120)) % (lane.steps * 100);

            const currentStep = Math.floor(position / 100);

            if (!lastTriggerTime[lane.id]) {

                lastTriggerTime[lane.id] = { step: -1, time: 0 };

            }

            if (currentStep !== lastTriggerTime[lane.id].step && 

                timestamp - lastTriggerTime[lane.id].time > 50) {

                playSample(lane.id);

                lastTriggerTime[lane.id] = { step: currentStep, time: timestamp };

            }

            lanePositions[lane.id] = position;

            drawLane(lane);

        });

        animationFrameId = requestAnimationFrame(animate);

    }

    // Start the app

    init();
</script>

```
</body>
</html>
 
